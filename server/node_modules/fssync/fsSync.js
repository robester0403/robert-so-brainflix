'use strict';
const fs = require('fs');
const fsPath = require('path');
const kit = require('./kit');
const fsSync = {};
const sync = {};


sync.isExists = fs.existsSync;


sync.isDir = (path)=>{
	return fs.statSync(path).isDirectory();
}


sync.isFile = (path)=>{
	return fs.statSync(path).isFile();
}


sync.writeFile = (...args)=>{
	sync.mkdirnameIfNeed(args[0]);
	fs.writeFileSync(...args);
}


sync.appendFile = (...args)=>{
	sync.mkdirnameIfNeed(args[0]);
	fs.appendFileSync(...args);
}


sync.set = (filePath, content, op)=>{
	op = op || {};
	if(op.append){
		sync.appendFile(filePath, content);
	}else{
		sync.writeFile(filePath, content);
	}
}


sync.get = (filePath, encoding)=>{
	let content = fs.readFileSync(filePath);
	if(typeof encoding === 'string'){
		content = content.toString(encoding);
	}
	return content;
}


sync.touch = (filePath)=>{
	sync.writeFile(filePath, '');
}


/**
 * @param {string} dirPath
 * @param {object} [op]
 * @param {boolean} [op.deep = true]
 * @param {string|boolean} [op.relative = true]
 * @return {array<string>}
 */
sync.readdir = sync.getList = (dirPath, op)=>{
	dirPath = kit.toUnixPath(dirPath, 1);
	op = Object.assign({
		deep: true,
		relative: true,
		basedir: dirPath,
	}, op);
	return readdir('', op, []);
}


/**
 * @param {string} dirPath
 * @param {object} op
 * @param {boolean} op.deep
 * @param {string} op.basedir
 * @param {string|boolean} op.relative
 * @param {array<string>} files
 * @return {array<string>}
 */
function readdir(dirPath, op, files){
	let list = fs.readdirSync(op.basedir + dirPath);
	list.forEach((name)=>{
		name = dirPath + name;
		let path = op.basedir + name;
		let isDir = sync.isDir(path);
		if(isDir){
			name += '/';
			path += '/';
		}
		if(typeof op.relative === 'string'){
			if(path.slice(0, op.relative.length) === op.relative){
				path = path.slice(op.relative.length);
			}
		}else{
			if(op.relative){
				path = name;
			}
		}
		files.push(path);
		if(isDir && op.deep){
			readdir(name, op, files);
		}
	});
	return files;
}


sync.mkdir = (dirPath)=>{
	sync.mkdirIfNeed(dirPath);
}


sync.rename = sync.move = (filePath, newPath)=>{
	sync.mkdirnameIfNeed(newPath);
	fs.renameSync(filePath, newPath);
}


sync.empty = (dirPath)=>{
	let paths = sync.getList(dirPath, {deep: true, relative: false});
	for(let i = paths.length - 1; i >= 0; i--){
		let path = paths[i];
		if(path.slice(-1) === '/'){
			fs.rmdirSync(path);
		}else{
			fs.unlinkSync(path);
		}
	}
}


sync.rmdir = (dirPath)=>{
	if(fs.existsSync(dirPath)){
		sync.empty(dirPath);
		fs.rmdirSync(dirPath);
	}
}


sync.remove = (path)=>{
	if(fs.existsSync(path)){
		if(sync.isDir(path)){
			sync.rmdir(path);
		}else{
			fs.unlinkSync(path);
		}
	}
}


sync.copyFile = (filePath, newPath)=>{
	sync.mkdirnameIfNeed(newPath);
	let fdr = fs.openSync(filePath, 'r');
	let fdw = fs.openSync(newPath, 'w');
	let bytes = 1;
	let pos = 0;
	let bufferLength = this._bufferLength || 64 * 1000;
	let buf = new Buffer(bufferLength);
	while(bytes > 0) {
		bytes = fs.readSync(fdr, buf, 0, bufferLength, pos);
		fs.writeSync(fdw, buf, 0, bytes);
		pos += bytes;
	}
	fs.closeSync(fdr);
	fs.closeSync(fdw);
}


sync.copyDir = (dirPath, newPath)=>{
	sync.mkdirIfNeed(newPath);
	dirPath = kit.toUnixPath(dirPath, 1);
	newPath = kit.toUnixPath(newPath, 1);
	sync.getList(dirPath, {deep: true, relative: true}).forEach((path)=>{
		if(path.slice(-1) !== '/'){
			sync.copyFile(dirPath + path, newPath + path);
		}else{
			sync.mkdir(newPath + path);
		}
	});
}


sync.copy = (path, newPath)=>{
	if(sync.isDir(path)){
		sync.copyDir(path, newPath);
	}else{
		sync.copyFile(path, newPath);
	}
}


/**
 * make the dir of file if need
 * @param {string} path - file path
 */
sync.mkdirnameIfNeed = (path)=>{
	let dirname = fsPath.dirname(path);
	sync.mkdirIfNeed(dirname);
}


/**
 * make the dirif need
 * @param {string} path - dir path
 */
sync.mkdirIfNeed = (path)=>{
	if(typeof path === 'string' && path !== ''){
		if(!fs.existsSync(path)){
			let paths = kit.getPaths(path);
			let list = [];
			
			//* get dir list of not exists
			paths.reverse().some((path, i)=>{
				if(!fs.existsSync(path)){
					list.push(path);
				}else{
					return true;
				}
			});
			
			//* mkdir list
			list.reverse().some((path, i)=>{
				fs.mkdirSync(path);
			});
		}
	}
}



//* copy sync method from fs
Object.keys(fs).forEach((syncKey)=>{
	if(/Sync$/.test(syncKey)){
		let key = syncKey.slice(0, -4);
		sync[key] = sync[key] || fs[syncKey];
	}
});

//* wrapper method
Object.keys(sync).forEach((key)=>{
	fsSync[key] = (...args)=>{
		let rs = false;
		try{
			rs = sync[key](...args);
			rs = rs === undefined ? true : rs;
		}catch(e){
			console.log(`fsSync.${key} method error:`, e);
		}
		return rs;
	};
});

module.exports = fsSync;